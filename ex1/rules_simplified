Reaching Definition

Relations:
Def(X,I): Variable X is defined at instruction Y
Use(X,I): Variable X is used at instruction I
Next(I,J): Instruction J is an immediate successor of instruction I
Gen(X,I): Definition X is generated by instruction I

Rules:
Kill(X, J): Definition X is killed by instruction J

Kill(X, J) :-  Def(X, I) & Def(X, J)

Thinking of --> Kill(X, J) :- Def(X, I) & DefPath(I, J) & Def(X, J)

Out(X, I): Definition X may reach the program point just after instruction I
Out(X, I) :- Gen(X, I)
Out(X, I) :- In(X, I) & !Kill(X,I)

In(X, J) :- Definition X may reach the program point just before instruction J
           Out(X, I) & Next(I, J)


TAINT ANALYSIS

Relations:
Taint(I): There exists a function call at instruction I that reads a tainted input
Sanitizer(I): There exists a function call at instruction I that sanitizes a tainted input
Div(X,I): There exists a division operation at instruction I whose divisor is variable X

Rules:
Edge(I, J) :- There exists an immediate data-flow from instruction I to J
Edge(I, J) :- Def(X, I) & Use(X, J) & Next(I,J)

Path(I, J) :- There exists a transitive tainted data-flow from instruction I to J
Path(I, J) :- Edge(I,J) & Taint(I)
Path(I, K) :- Path(I,J) & Edge(J,K) & !Sanitizer(J)

Alarm( J ) :- There exists a potential exploitable divide-by-zero error at instruction J
            Path(I, J) & Div(X, J)
            OR?? Def(X, I) & Path(I, J) & Div(X, J)